- Name: AMES
- Author: Kyle Den Hartog
- Start Date: 2018-07-10 (approximate, backdated)
- HIPE PR: (leave this empty)
- Feature Branch: https://github.com/kdenhartog/indy-sdk/tree/multiplex-poc

# AMES
[summary]: #summary

Agent Message Encryption Serialization (AMES) are intended to be a standardized format that allows for all necessary information to encrypt, decrypt, and perform routing can be found in the message while remaining asynchronous. In this HIPE we'll describe the API of the Pack and Unpack functions. This HIPE does not currently go into detail about how to use the API to prevent data exposure, but should be updated to detail this before being accepted.

# Motivation
[motivation]: #motivation

Many aspects of this hipe have been derived from [JSON Web Encryption - RFC 7516](https://tools.ietf.org/html/rfc7516). It has diverged from this spec due to assumptions around TLS and encryption schemes, as well as to focus on the DIDs usecase. AMES are intended to provide the following properties:

* provide a standard serialization format
* Handles encrypting messages for 1 or many receivers
* Keeps messaging protocol asynchronous

# Serialization Descriptions

## JSON Serialization

### Authcrypt example
```
{
    "recipients" : [
        {
            "enc_from" : <b64URLencode(anoncrypted(<sender_verkey>))>,
            "cek_nonce": <nonce to decrypt cek>
            "e_cek" : <encrypted symmetrical key to unlock ciphertext>,
            "to" : "<recipient_verkey>"
        },
        {    
            "enc_from" : <b64URLencode(anoncrypted(<sender_verkey>))>,
            "cek_nonce": <nonce to decrypt cek>
            "e_cek" : <encrypted symmetrical key to unlock ciphertext>,
            "to" : "<recipient_verkey>"
        }
    ],
    "ver" : "AuthAMES/1.0",
    "enc" : "xsalsa20poly1305",
    "ciphertext" : <message ciphertext>,
    "iv" : <nonce>,
}
```

### Authcrypt details

Authcrypting works by using two keys, one from the sender's DID Doc and one from the receiver's DID Document, to generate a symmetrical key specific to the two agents involved in the encryption process. The sender's key is explicitly listed ("from") and then encrypted in the "enc_header" object to prevent correlating the two keys ("to" and "from") which are communicating. These two keys are used to encrypt the cek.

The algorithm for auth encrypting a message with this structure is as follows:

1. generate a random nonce ("iv")
2. generate a random ephemeral symmetrical key (plaintext of cek)
3. secretbox_detached (src/utils/crypto/xsalsa20/sodium.rs currently) encrypt the message (plaintext of ciphertext)
4. create an array of recipient keys (one "to" for each recipient key)
5. encrypt (uses crypto_box_easy from libsodium) the ephemeral symmetrical key with one "to" and sender's verkey keys and one "cek_nonce" for each recipient to produce one "cek" for each recipient key
6. encrypt the sender's verkey using sealed_encrypt (uses sealed_box from libsodium)
7. serialize the data into the Authcrypt json structure listed above

The algorithm to decrypt the message is as follows:

1. identify the recipient verkey used to decrypt (e.g. my phone's key)
2. loop through the recipients list to identify the recipient object relevant to the agent performing the algorithm
3. decrypt the "enc_from" from the recipient object found in step 2 using the decrypt_sealed function and the key from step 1. This produces the sender's verkey
4. decrypt the "cek" using the recipient privkey and the decrypted "enc_from" and the cek_nonce with the decrypt function. This produces the ephemeral symmetrical key
5. decrypt the ciphertext with the ephemeral symmetrical key and the iv using decrypt_detached (src/utils/crypto/xsalsa20/sodium.rs currently). This will give you the decrypted message

### Anoncrypt example
```
{
    "recipients" : [
        {
            "to" : "<recipient_verkey>",
            "e_cek" : <encrypted symmetrical key to unlock ciphertext>
        },
        {    
            "to" : "<recipient_verkey>",
            "e_cek" : <encrypted symmetrical key to unlock ciphertext>
        }
    ],
    "ver" : "AnonAMES/1.0",
    "enc" : "xsalsa20poly1305",
    "ciphertext" : <message ciphertext>,
    "iv" : <nonce>,
}
```

### Anoncrypt details

The algorithm to anon encrypting a message with this structure is as follows:

1. generate a random nonce ("iv")
2. generate a random ephemeral symmetrical key (plaintext of cek)
3. encrypt (src/utils/crypto/xsalsa20/sodium.rs currently which uses secretbox::seal from libsodium) encrypt the message (plaintext of ciphertext)
4. create an array of recipient keys (one "to" for each recipient key)
5. encrypt_sealed the "cek" using the "to" key. (The ephemeral sender's verkey and nonce is generated by the function and appended to the ciphertext)
6. serialize the data into the Anoncrypt json structure listed above

The algorithm to anon decrypt a message with this structure is as follows:

1. identify the recipient verkey used to decrypt (e.g. my phone's key)
2. loop through the recipients list to identify the recipient object relevant to the agent performing the algorithm
3. decrypt_sealed the "cek" using the corresponding private key from the recipient key used in step 1
5. decrypt the ciphertext with the ephemeral symmetrical key and the iv using decrypt_detached (src/utils/crypto/xsalsa20/sodium.rs currently). This will give you the decrypted message



## recipients field descriptions

#### "recipients"
    This is a list of json objects which contains 1 "enc_header" (when authcrypting the "cek", this is not included when anoncrypting "cek"), 1 "to", and 1 "cek" for each recipient expected to get the message.
    
#### "enc_from"     
    The encrypted from is used to protect the sender's identity by encrypting the sender's verkey. The "to" key that is listed within the same JSON object should be used to decrypt the message. The corresponding ephemeral key is appended to the enc_from text by Sodium Oxide (the underlying crypto library), so the ephemeral key won't be explicitly listed within this Serialization structure. The nonce used to decrypt enc_from is also appended by the underlying library.

#### "to"
    This is the verkey (aka public key) of the recipient agent. If multiple agents are going to receive the same message, then this will be different for each header.

#### "e_cek"
    This is the encrypted text of the symmetrical key which when decrypted can be used to decrypt the "ciphertext". It should be noted that when anoncrypt is being used to encrypt the "cek" that the sender ephemeral key used the cek is appended onto the cek text by the underlying library so the "from" section is null rather than listing the sender ephemeral key. 

## additional data field descriptions

#### "ver"
    This is the version of the current json format. This allows for multiple different formats of JSON to be added over time without breaking changes. It should be noted that at this time, to upgrade versions would likely require significant refactoring and is discouraged unless absolutely necessary.

#### "enc"
    This is a string to describe the encryption scheme used to encrypt the "ciphertext". Currently only XSalsa20 is supported, but XChacha20 or AES-GCM could be added with relative ease if needed. XSalsa20 was selected because it's the only encryption format supported by Tweet-Nacl's javascript library which is used by numerous other projects.

#### "iv" 
    This is the nonce which is used to decrypt the "ciphertext".

#### "ciphertext"
    This is the message that is being decrypted by the multiple recipients. The contained text SHOULD correspond with a message family structure which will be defined in the future.

## Compact Serialization

Note: I have removed this serialization to consolidate to a single serialization format, however if there's a need it is possible to support compact serialization format similar to how JWEs do in the future. Right now it adds additional unnecessary complexity.


###

# IndySDK API Additions

#### indy_auth_pack_message(command_handle, wallet_handle, message, recv_keys, my_vk) -> JSON String:
The purpose of this function is to take in a message, encrypt the message with authcrypt for the keys specified and output a JSON string using the JSON serialization format.

The parameters should be used in this way:
    
    command_handle: This command handle is used to track callbacks for the calls of this API.

    wallet_handle: this is the wallet_handle that contains the related data such as keys to be able to complete the function.

    message: This should be the message that is intended to be encrypted. It's required and should be of type String. The most common forms of messages that will be passed in here are json strings that follow the format of a particular message family.
    
    recv_keys: This is a list of verkeys passed as a string. If only 1 key is passed in, then a Compact serialization will be outputed. If > 1 keys are passed in then JSON serialization will be outputted from this function.

    my_vk: This is an optional parameter that must include a verkey as a string if auth is set to true (authcrypting). Otherwise, this must be set to none if anoncrypt is being used.  

output: a string in the form of either JSON serialization or Compact serialization

#### indy_anon_pack_message(command_handle, wallet_handle, message, recv_keys) -> JSON String:
The purpose of this function is to take in a message, encrypt the message with anoncrypt for the keys specified and output a JSON string using the JSON serialization format.

The parameters should be used in this way:
    
    command_handle: This command handle is used to track callbacks for the calls of this API.
    
    message: This should be the message that is intended to be encrypted. It's required and should be of type String. The most common forms of messages that will be passed in here are json strings that follow the format of a particular message family.
    
    recv_keys: This is a list of verkeys passed as a string. If only 1 key is passed in, then a Compact serialization will be outputed. If > 1 keys are passed in then JSON serialization will be outputted from this function.

output: a string in the form of either JSON serialization or Compact serialization

#### unpack_message(AMES, my_vk) -> plaintext message:
The unpack function is used to decrypt a message on the receiver side. It will output the plaintext of the corresponding pack_message if the verkey provided is found within the header. This works for both compact serializations and for JSON serializations.

The parameters should be used in this way:

    command_handle: This command handle is used to track callbacks for the calls of this API.

    wallet_handle: this is the wallet_handle that contains the related data such as keys to be able to complete the function.

    ames_json: This should pass in a json string that follows the serialization format from above.

    my_vk: This should be the verkey that you wish to use to decrypt the message.

output: A decrypted message, if authcrypt was used. Will return a verkey. If Anoncrypted will return empty string.

## Additional Questions
