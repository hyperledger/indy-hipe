- Name: supporting-multiple-key-types
- Author: lovesh.harchandani@evernym.com
- Start Date: 2018-10-22
- PR: (leave this empty)
- Jira Issue: (leave this empty)

# Summary
[summary]: #summary

Supporting more than 1 key type (secp256k1, etc) for signing and encryption in Indy. This implies on-ledger and off-ledger usages. Different keys are represented by prefixing them with a fixed size identifier. 
This HIPE does not address keys used for BLS signatures. 
This HIPE is not proposing to support any specific curve.

# Motivation
[motivation]: #motivation

Indy currently uses EdDSA for signing using ed25519 keys. For encryption, it uses X25519 for key exchange (ECDH) using Curve25519 to derive a shared secret and then XSalsa20+Poly1305 for authenticated symmetric encryption. That leaves out a large chunk of users, developers and ecosystems which rely on the secp256k1 curve; the curve used by Bitcoin, Ethereum and their many forks. Moreover the existing ed25519 and Curve25519 curves might be vulnerable in the future. Hence we want Indy to be flexible to support future cryptography.

# Tutorial
[tutorial]: #tutorial

There are 2 kinds of keys in Indy (excluding BLS keys)

1. Keys with size 32 bytes. These are either ed25519 keys if used in a signing context or Curve 25519 keys if used in encryption context.
2. Keys with size greater than or less than 32 bytes. For these keys, read the bytes before the colon, i.e `:`; this is the prefix which determines what kind of key follows after `:`. The prefix is at most 7 bytes and the key is at most 64 bytes. (The reason is described under Reference).  

The keys are always encoded as base58.

```
<32 byte ed25519 or Curve 25519 key, base58 encoded>
```
------------- OR --------------------------------
```
<at most 7 byte prefix>:<at most 64 byte key, base58 encoded>
```

The ledger and indy-sdk both follow these rules and reject the operation when either of the following is true.  

1. A prefix greater than 7 bytes is found.
2. A key with size (excluding prefix) greater than 64 bytes is found.
3. A key with a unsupported prefix are found.

They might do further checks to validate the provided key.

# Reference
[reference]: #reference

This is a non-breaking change as the exisiting keys will continue to be supported. No migration of any sort is needed.

To avoid someone sending large keys and putting junk on the ledger, the prefix is maximum of 7 bytes and the key is at most 64 bytes. Unless we have an accurate fees mechanism that accounts for byte size of transaction and a "storage rent" mechanism, such a guard is needed.
The reason for chooising 7 bytes for prefix is that it allows `ed25519` and `curve25519`. Larger words like `secp256k1` can be shortened to `k256` which is their popular short name. The 64 byte limit for keys comes from a few facts;
a. Currently supported ed25519, Curve25519 and anticipated curve secp256k1 have 32 byte keys.
b. Popular NIST curves NIST P-256 and NIST P-384 fit under 64 bytes.
c. Safe curves like Ed448 and Curve511187 are also under 64 bytes.

In case of transactions creating DIDs or changing keys, the ledger looks at the verification key, validates with above rules during static validation, if the validation fails, it discards the transaction. Also if the prefix is not supported the ledger discards the transaction during static validation. This means that to support a new curve, a supermajority (>66%) of the nodes of the network have to update.

Similarly indy-sdk will also support different curves and that will be used in encryption primitives like `anoncrypt` and `authcrypt` apart from DID related code. Evidently for encryption primitives like `anoncrypt` and `authcrypt` to support a curve, it is not needed for the ledger to support that curve too.

Payment addresses which are currently generated by concatenating the public key with a checksum are generated by taking a checksum of the public key including the prefix like `k256:ax239dd...` and adding a checksum to it.

# Drawbacks
[drawbacks]: #drawbacks

If an insecure curve becomes one of the acceptable curves in indy-sdk or ledger, it might leave people vulnerable.

# Rationale and alternatives
[alternatives]: #alternatives

This lets Indy interop with other popular ecosystems.
It makes a tradeoff in implementation trading efficiency for readability of keys. The prefix could have been represented as a bitset saving off about 5 bytes.

# Prior art
[prior-art]: #prior-art

PEM files which are used to represent public keys somewhat similarly but use base64. We do not use base64 but base58 since that is the encoding format used in Indy all over.

# Unresolved questions
[unresolved]: #unresolved-questions

- Should we address BLS keys too? We can implement later as there is no pressing need for that.
- Do we need a checksum in public key?
