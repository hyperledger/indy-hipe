

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>HIPE 0022: Cross-Domain Messaging &mdash; Indy Project Enhancements  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Indy Project Enhancements
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html">HIPE 0011-cred-revocation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#motivation">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#tutorial">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#reference">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#drawbacks">Drawbacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#rationale-and-alternatives">Rationale and alternatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#prior-art">Prior art</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0011-cred-revocation/README.html#unresolved-questions">Unresolved questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#motivation">Motivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#tutorial">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#reference">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#drawbacks">Drawbacks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#rationale-and-alternatives">Rationale and alternatives</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#prior-art">Prior art</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0012-concurrency-improvement/README.html#unresolved-questions">Unresolved questions</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Indy Project Enhancements</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>HIPE 0022: Cross-Domain Messaging</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/text/0022-cross-domain-messaging/README.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <ul class="simple">
<li>Name: cross-domain-messaging</li>
<li>Author: Stephen Curran (swcurran&#64;gmail.com)</li>
<li>Start Date: 2018-08-13</li>
<li>PR: https://github.com/hyperledger/indy-hipe/pull/35</li>
</ul>
<div class="section" id="hipe-0022-cross-domain-messaging">
<span id="hipe-0022-cross-domain-messaging"></span><h1>HIPE 0022: Cross-Domain Messaging<a class="headerlink" href="#hipe-0022-cross-domain-messaging" title="Permalink to this headline">¶</a></h1>
<p>There are two layers of messages that combine to enable <strong>interoperable</strong> self-sovereign identity Agent-to-Agent communication. At the highest level are Agent Messages - messages sent between Identities to accomplish some shared goal. For example, establishing a connection between identities, issuing a Verifiable Credential from an Issuer to a Holder or even the simple delivery of a text Instant Message from one person to another. Agent Messages are delivered via the second, lower layer of messaging - Wire. A Wire Message is a wrapper (envelope) around an Agent Message to permit sending the message from one Agent directly to another Agent. An Agent Message going from its Sender to its Receiver may be passed through a number of Agents, and a Wire Message is used for each hop of the journey.</p>
<p>This HIPE addresses Cross Domain messaging to enable interoperability. This is one of a series of related HIPEs that address interoperability, including DIDDoc Conventions, Agent Messages and Wire Messages. Those HIPEs should be considered together in understanding Agent-to-Agent messaging.</p>
<p>In order to send a message from one Identity to another, the sending Identity must know something about the Receiver’s domain - the Receiver’s configuration of Agents. This HIPE outlines how a domain MUST present itself to enable the Sender to know enough to be able to send a message to an Agent in the domain.  In support of that, a family of Agent Messages (currently consisting of just one Message Type) is introduced to route messages through a network of Agents in both the Sender and Receiver’s domain. This HIPE provides the specification of the “Forward” Agent Message Type - an envelope that indicates the destination of the Message without revealing anything about the message.</p>
<p>The goal of this HIPE is to define the rules that domains MUST follow to enable the delivery of Agent messages from a Sending Agent to a Receiver Agent in a secure and privacy-preserving manner.</p>
</div>
<div class="section" id="motivation">
<span id="motivation"></span><h1>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h1>
<p>The purpose of this HIPE and its related HIPEs is to define a layered Messaging protocol such that we can ignore the transport of messages as we discuss the much richer Agent Messaging types and interactions. That is, we can assume that there is no need to include in an Agent message anything about how to route the message to the Receiver - it just magically happens. Alice (via her App Agent) sends a message to Bob, and (because of implementations based on this series of HIPEs) we can ignore how the actual message got to Bob’s App Agent.</p>
<p>Put another way - these HIPEs are about envelopes. They define a way to put a message - any message - into an envelope, put it into an outbound mailbox and have it magically appear in the Receiver’s inbound mailbox in a secure and privacy-preserving manner. Once we have that, we can focus on letters and not how letters are sent.</p>
<p>Most importantly for Agent to Agent interoperability, this HIPE clearly defines the assumptions necessary to deliver a message from one domain to another - e.g. what exactly does Alice have to know about Bob’s domain to send Bob a message?</p>
</div>
<div class="section" id="tutorial">
<span id="tutorial"></span><h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="core-messaging-goals">
<span id="core-messaging-goals"></span><h2>Core Messaging Goals<a class="headerlink" href="#core-messaging-goals" title="Permalink to this headline">¶</a></h2>
<p>These are vital design goals for this HIPE:</p>
<ol class="simple">
<li><strong>Sender Encapsulation</strong>: We SHOULD minimize what the Receiver has to know about the domain (routing tree or agent infrastructure) of the Sender in order for them to communicate.</li>
<li><strong>Receiver Encapsulation</strong>: We SHOULD minimize what the Sender has to know about the domain (routing tree or agent infrastructure) of the Receiver in order for them to communicate.</li>
<li><strong>Independent Keys</strong>: Private signing keys SHOULD NOT be shared between agents; each agent SHOULD be separately identifiable for accounting and authorization/revocation purposes.</li>
<li><strong><em>Need To Know</em> Information Sharing</strong>: Information made available to intermediary agents between the Sender and Receiver SHOULD be minimized to what is needed to perform the agent’s role in the process.</li>
</ol>
</div>
<div class="section" id="assumptions">
<span id="assumptions"></span><h2>Assumptions<a class="headerlink" href="#assumptions" title="Permalink to this headline">¶</a></h2>
<p>The following are assumptions upon which this HIPE is predicated.</p>
<div class="section" id="terminology">
<span id="terminology"></span><h3>Terminology<a class="headerlink" href="#terminology" title="Permalink to this headline">¶</a></h3>
<p>The following terms are used in this HIPE with the following meanings:</p>
<ul class="simple">
<li>Domain - a set of Agents collaborating on behalf of an Identity<ul>
<li>It’s assumed that the Agents of a Domain were developed by a single vendor and so MAY have implementation-specific mechanisms for tracking extra information about one another.</li>
<li>An example of two Domains is provided in the image below.</li>
</ul>
</li>
<li>Edge Agents - the Agents involved in sending (creating) and receiving (processing) an Agent Message<ul>
<li>Sender - the Agent sending an original Agent Message</li>
<li>Receiver - the Agent intended to receive an Agent Message from the Sender</li>
<li><strong>Note</strong>: A message MAY pass through many Agents between the Sender and Receiver</li>
</ul>
</li>
<li>Domain Endpoint - a physical endpoint for messages into domains that MUST be assumed to be shared across many Identities<ul>
<li>Shared by many identities (e.g. https://endpoint.agentsRus.com)</li>
<li>Agency - the handler for messages sent to the Domain Endpoint.</li>
</ul>
</li>
<li>Routing Agent - the single identity-controlled entry point for a Domain per relationship (DID)<ul>
<li>A message addressed to a DID and delivered to a Domain Endpoint is passed directly to the Routing Agent for that DID</li>
</ul>
</li>
<li>DID - reference to the literal Decentralized ID text<ul>
<li>e.g. did:sov:1234abcd</li>
</ul>
</li>
<li>DID#keyname - reference to the DID appended with “#” and a specific key from the DIDDoc<ul>
<li>e.g. did:sov:1234abcd#1 references key “1” of the “did:sov:1234abcd” DIDDoc.</li>
<li><strong>Note</strong>: The #keyname is NOT the actual Public Key - it’s a reference to an entry in the DIDDoc that contains the Public Key.</li>
</ul>
</li>
</ul>
<div class="section" id="diddoc">
<span id="diddoc"></span><h4>DIDDoc<a class="headerlink" href="#diddoc" title="Permalink to this headline">¶</a></h4>
<p>The term “DIDDoc” is used in this HIPE as it is defined in the <a class="reference external" href="https://w3c-ccg.github.io/did-spec/">DID Specification</a>:</p>
<ul class="simple">
<li>a collection of public keys and endpoints,</li>
<li>controlled by an identity,</li>
<li>associated with a DID, and</li>
<li>used for a relationship.</li>
</ul>
<p>A DID can be resolved to get its corresponding DIDDoc by any Agent that needs access to the DIDDoc. This is true whether talking about a DID on the Public Ledger, or a DID persisted to a microledger. In the case of a microledger, it’s the (implementation specific) domain’s responsibility to ensure such resolution is available to all Agents requiring it.</p>
</div>
</div>
<div class="section" id="messages-are-private">
<span id="messages-are-private"></span><h3>Messages are Private<a class="headerlink" href="#messages-are-private" title="Permalink to this headline">¶</a></h3>
<p>Agent Messages sent from a Sender to a Receiver SHOULD be private. That is, the Sender SHOULD encrypt the message with a public key for the Receiver. Any agent in between the Sender and Receiver will know only to whom the message is intended (by DID and possibly keyname within the DID), not anything about the message.</p>
</div>
<div class="section" id="the-sender-knows-the-receiver">
<span id="the-sender-knows-the-receiver"></span><h3>The Sender Knows The Receiver<a class="headerlink" href="#the-sender-knows-the-receiver" title="Permalink to this headline">¶</a></h3>
<p>This HIPE assumes that the Sender knows the Receiver’s DID and, within the DIDDoc for that DID, the keyname to use for the Receiver’s Agent. How the Sender knows the DID and keyname to send the message is not defined within this HIPE - that is a higher level concern.</p>
<p>The Receiver’s DID MAY be a public or pairwise DID, and MAY be on a Public Ledger or a microledger.</p>
</div>
</div>
<div class="section" id="example-domain-and-diddoc">
<span id="example-domain-and-diddoc"></span><h2>Example: Domain and DIDDoc<a class="headerlink" href="#example-domain-and-diddoc" title="Permalink to this headline">¶</a></h2>
<p>The following is an example of an arbitrary pair of domains that will be helpful in defining the requirements in this HIPE.</p>
<p><img alt="Example Domains: Alice and Bob" src="../../_images/domains.jpg" /></p>
<p>In the diagram above:</p>
<ul class="simple">
<li>Alice has<ul>
<li>1 Edge Agent - “1”</li>
<li>1 Routing Agent - “2”</li>
<li>1 Domain Endpoint - “8”</li>
</ul>
</li>
<li>Bob has<ul>
<li>3 Edge Agents - “4”, “5” and “6”<ul>
<li>“6” is an Edge Agent in the cloud, “4” and “5” are physical devices.</li>
</ul>
</li>
<li>1 Routing Agent - “3”</li>
<li>1 Domain Endpoint - “9”</li>
</ul>
</li>
</ul>
<div class="section" id="bob-s-did-for-his-relationship-with-alice">
<span id="bob-s-did-for-his-relationship-with-alice"></span><h3>Bob’s DID for his Relationship with Alice<a class="headerlink" href="#bob-s-did-for-his-relationship-with-alice" title="Permalink to this headline">¶</a></h3>
<p>Bob’s domain has 3 devices he uses for processing messages - two phones (4 and 5) and a cloud-based agent (6). However, in Bob’s relationship with Alice, he ONLY uses one phone (4) and the cloud-based agent (6). Thus the key for device 5 is left out of the DIDDoc (see below).</p>
<p>Note that the keyname for the Routing Agent (3) is called “routing”. This is an example of the kind of convention needed to allow the Sender’s agents to know the keys for Agents with a designated role in the receiving domain - as defined in the <code class="docutils literal notranslate"><span class="pre">DIDDoc</span> <span class="pre">Conventions</span></code> HIPE.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span>{
  &quot;@context&quot;: &quot;https://w3id.org/did/v1&quot;,
  &quot;id&quot;: &quot;did:sov:1234abcd&quot;,
  &quot;publicKey&quot;: [
    {&quot;id&quot;: &quot;routing&quot;, &quot;type&quot;: &quot;RsaVerificationKey2018&quot;,  &quot;owner&quot;: &quot;did:sov:1234abcd&quot;,&quot;publicKeyPem&quot;: &quot;-----BEGIN PUBLIC X…&quot;},
    {&quot;id&quot;: &quot;4&quot;, &quot;type&quot;: &quot;RsaVerificationKey2018&quot;,  &quot;owner&quot;: &quot;did:sov:1234abcd&quot;,&quot;publicKeyPem&quot;: &quot;-----BEGIN PUBLIC 9…&quot;},
    {&quot;id&quot;: &quot;6&quot;, &quot;type&quot;: &quot;RsaVerificationKey2018&quot;,  &quot;owner&quot;: &quot;did:sov:1234abcd&quot;,&quot;publicKeyPem&quot;: &quot;-----BEGIN PUBLIC A…&quot;}
  ],
  &quot;authentication&quot;: [
    {&quot;type&quot;: &quot;RsaSignatureAuthentication2018&quot;, &quot;publicKey&quot;: &quot;did:sov:1234abcd#4&quot;}
  ],
  &quot;service&quot;: [
    {&quot;type&quot;: &quot;Agency&quot;, &quot;serviceEndpoint&quot;: &quot;did:sov:fghi8377464&quot; }
    // or &quot;serviceEndpoint&quot;: &quot;https://example.com/endpoint/8377464&quot; and add the #domain key (above)
  ]
}
</pre></div>
</div>
<p>For the purposes of this discussion we are defining the message flow to be:</p>
<blockquote>
<div>1 –&gt; 2 –&gt; 8 –&gt; 9 –&gt; 3 –&gt; 4</div></blockquote>
<p>However, that flow is arbitrary. Even so, some Wire Message hops are required:</p>
<ul class="simple">
<li>1 is the Sender in this case and so must send the first message.</li>
<li>9 is the Domain Endpoint of Bob’s domain and so must receive the message</li>
<li>4 is the Receiver in this case and so must receive the message.</li>
</ul>
<p>In the section below on Domain Configuration, we will also declare that:</p>
<ul class="simple">
<li>The Routing Agent for Bob’s Domain (3) must receive the message from 9</li>
</ul>
</div>
</div>
<div class="section" id="wire-messages">
<span id="wire-messages"></span><h2>Wire Messages<a class="headerlink" href="#wire-messages" title="Permalink to this headline">¶</a></h2>
<p>A Wire Message is used to transport any Agent Message from one Agent directly to another. In our example message flow above, there are five Wire Messages sent, one for each hop in the flow. The separate <code class="docutils literal notranslate"><span class="pre">Wire</span> <span class="pre">Messages</span></code> HIPE (<em>reference to be added</em>) covers those details.</p>
</div>
<div class="section" id="agent-message-format">
<span id="agent-message-format"></span><h2>Agent Message Format<a class="headerlink" href="#agent-message-format" title="Permalink to this headline">¶</a></h2>
<p>An Agent Message defines the format of messages processed by Agents. Details about the general form of Agent Messages can be found in the <code class="docutils literal notranslate"><span class="pre">Agent</span> <span class="pre">Message</span></code> HIPE (<em>reference to be added</em>). A list of specific Agent Message types is being assembled (<em>reference to be added</em>).</p>
<p>This HIPE specifies (below) the “Forward” message type, a part of the “Routing” family of Agent Messages.</p>
</div>
<div class="section" id="did-and-diddoc">
<span id="did-and-diddoc"></span><h2>DID and DIDDoc<a class="headerlink" href="#did-and-diddoc" title="Permalink to this headline">¶</a></h2>
<p>A DID owned by the Receiver is resolvable by the Sender as a DIDDoc using either a Public Ledger or a microledger. The related <code class="docutils literal notranslate"><span class="pre">DIDDoc</span> <span class="pre">Conventions</span></code> HIPE defines the required contents of a DIDDoc for receiving Agent to Agent messages (<em>reference to be added</em>) that supports the conventions defined in this document.</p>
</div>
<div class="section" id="cross-domain-interoperability">
<span id="cross-domain-interoperability"></span><h2>Cross Domain Interoperability<a class="headerlink" href="#cross-domain-interoperability" title="Permalink to this headline">¶</a></h2>
<p>A key goal for interoperability is that we want other domains to know just enough about the configuration of a domain to which they are delivering a message, but no more. The following walks through those minimum requirements.</p>
<div class="section" id="required-the-did-and-diddoc">
<span id="required-the-did-and-diddoc"></span><h3>Required: The DID and DIDDoc<a class="headerlink" href="#required-the-did-and-diddoc" title="Permalink to this headline">¶</a></h3>
<p>As noted above, the Sender of an Agent to Agent Message has the DID of the Receiver, and knows the key from the DIDDoc to use for the Receiver’s Agents.</p>
<blockquote>
<div>Example: Alice wants to send a message from her phone (1) to Bob’s phone (4). She has Bob’s B:did&#64;A:B, the DID/DIDDoc Bob created and gave to Alice to use for their relationship. Alice created A:did&#64;A:B and gave that to Bob, but we don’t need to use that in this example. The contents of the DIDDoc for B:did&#64;A:B are presented above.</div></blockquote>
</div>
<div class="section" id="required-end-to-end-encryption-of-the-agent-message">
<span id="required-end-to-end-encryption-of-the-agent-message"></span><h3>Required: End-to-End encryption of the Agent Message<a class="headerlink" href="#required-end-to-end-encryption-of-the-agent-message" title="Permalink to this headline">¶</a></h3>
<p>The Agent Message from the Sender SHOULD be hidden from all Agents other than the Receiver. Thus, it SHOULD be encrypted with the Public Key of the Receiver. Based on our assumptions, the Sender can get the Public Key of the Receiver because they know the DID#keyname string, can resolve the DID to the DIDDoc and find the public key associated with DID#keyname. In our example above, that is the key associated with “did:sov:1234abcd#4”.</p>
<p>Most Sender-to-Receiver messages will be sent between parties that have shared pairwise DIDs. When that is true, the Sender will (usually) AuthCrypt the message. If that is not the case, or for some other reason the Sender does not want to AuthCrypt the message, AnonCrypt will be used. In either case, the Indy-SDK <code class="docutils literal notranslate"><span class="pre">pack()</span></code> function that is used for the encryption inserts in the JOSEhdr part of its output the type of encryption used.</p>
<p>To route the message to the Receiver, the Sender sends a ‘Forward’ message with the ‘to’ address being the DID#keyname of the Receiver. It is assumed that the Receiver can determine the from <code class="docutils literal notranslate"><span class="pre">did</span></code> based on the <code class="docutils literal notranslate"><span class="pre">to</span></code> DID using their pairwise relationship.</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;@type&quot;</span> <span class="p">:</span> <span class="s2">&quot;did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/routing/1.0/forward&quot;</span><span class="p">,</span>
  <span class="nt">&quot;to&quot;</span>   <span class="p">:</span> <span class="s2">&quot;did:sov:1234abcd#4&quot;</span><span class="p">,</span>
  <span class="nt">&quot;msg&quot;</span>  <span class="p">:</span> <span class="s2">&quot;&lt;pack(AgentMessage,valueOf(did:sov:1234abcd#4), privKey(A.did@A:B#1))&gt;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<ul class="simple">
<li>the <code class="docutils literal notranslate"><span class="pre">&#64;type</span></code> value is in the precise URI format for the “forward” message type</li>
<li>Indy-SDK’s “pack” function is used to AuthCrypt the message using the Receiver’s public key and the Sender’s private key.<ul>
<li>If the Sender wishes to remain anonymous or knows the Receiver does not know the Sender’s public key, AnonCrypt is used.</li>
<li>More details about the Indy-SDK <code class="docutils literal notranslate"><span class="pre">pack()</span></code> function can be found in the <code class="docutils literal notranslate"><span class="pre">Wire</span> <span class="pre">Messages</span></code> HIPE (<em>reference to be provided</em>).</li>
</ul>
</li>
<li>The Indy-SDK’s “unpack()” function MUST return the public key of the private key used to sign the message. See the note below for the background on this.</li>
</ul>
<blockquote>
<div>The bullet above about the unpack() function returning the signer’s public key deserves some additional attention. The Receiver of the message knows from the “to” field the DID to which the message was sent. From that, the Receiver is expected to be able to determine the DID of the Sender, and from that, access the Sender’s DIDDoc. However, knowing the DIDDoc is not enough to know from whom the message was sent - which key was used to send the message, and hence, which Agent controls the Sending private key. This information MUST be made known to the Receiver (from unpack()) when AuthCrypt is used so that the Receiver knows which key was used to the send the message and can, for example, use that key in responding to the arriving Message.</div></blockquote>
</div>
<div class="section" id="required-minimize-information-available-to-the-shared-domain-endpoint">
<span id="required-minimize-information-available-to-the-shared-domain-endpoint"></span><h3>Required: Minimize information available to the Shared Domain Endpoint<a class="headerlink" href="#required-minimize-information-available-to-the-shared-domain-endpoint" title="Permalink to this headline">¶</a></h3>
<p>We want to minimize the knowledge about the Receiver of the Agent Message for minimally trusted agents. In this case, “minimally trusted” are all agents before the designated “Routing Agent” for the Receiver. The “Routing Agent” must know the exact destination (B:did&#64;A:B#keyname) of the Receiver, but Agents handling the message prior to the Routing Agent do not - they just need the DID (B:did&#64;A:B) of the Receiver.</p>
<p>To hide other than the minimum information, the Sender wraps the “Forward” message in a second forward message, this time for the Routing Agent of the Receiver (<code class="docutils literal notranslate"><span class="pre">3</span></code> in our example). The Sender must be able to get the public key of the Routing Agent from the DIDDoc.</p>
<p>The Sender prepares the following message:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;@type&quot;</span> <span class="p">:</span> <span class="s2">&quot;did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/routing/1.0/forward&quot;</span><span class="p">,</span>
  <span class="nt">&quot;to&quot;</span>   <span class="p">:</span> <span class="s2">&quot;did:sov:1234abcd&quot;</span><span class="p">,</span>
  <span class="nt">&quot;msg&quot;</span>  <span class="p">:</span> <span class="s2">&quot;&lt;pack(ForwardMessage,valueOf(did:sov:1234abcd#routing))&gt;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Notes</strong></p>
<ul class="simple">
<li>Indy-SDK’s “<code class="docutils literal notranslate"><span class="pre">pack()</span></code>” function is used to Anon encrypt the message using the Routing Agent’s public key.<ul>
<li>Since AnonCrypt is used for the message, the unpack() function does not have the Sender’s public key to provide to the Routing Agent.</li>
</ul>
</li>
</ul>
<p>The Sender can now send the Forward Agent Message on its way via the first of the Wire messages. In our example, the Sender sends the Agent Message to 2, who in turn sends it to 8. That of course, is arbitrary - the Sender’s Domain could have any configuration of Agents. The Agent Message above is passed unchanged, with each Agent able to see the <code class="docutils literal notranslate"><span class="pre">&#64;type</span></code>, <code class="docutils literal notranslate"><span class="pre">to</span></code> and <code class="docutils literal notranslate"><span class="pre">msg</span></code> fields as described above. This continues until the outer <code class="docutils literal notranslate"><span class="pre">forward</span></code> message gets to the Receiver’s Routing Agent, where it is processed (to expose the inner <code class="docutils literal notranslate"><span class="pre">forward</span></code> message). Per the Wire Message HIPE (<em>reference to be added</em>), between Agents the Agent Message is pack()’d and unpack()’d as appropriate or required.</p>
<p>The diagram below shows the required use of the <code class="docutils literal notranslate"><span class="pre">forward</span></code> messages to encrypt the message all the way to the Receiver, and again all the way to the Routing Agent.</p>
<p><img alt="Example Forward Messages" src="../../_images/forwarding.jpg" /></p>
</div>
<div class="section" id="required-cross-domain-wire-message-encryption">
<span id="required-cross-domain-wire-message-encryption"></span><h3>Required: Cross Domain Wire Message Encryption<a class="headerlink" href="#required-cross-domain-wire-message-encryption" title="Permalink to this headline">¶</a></h3>
<p>While within a domain the Agents MAY choose to use encryption or not when sending Wire Messages from Agent to Agent, encryption MUST be used when sending a Wire Message into the Receiver’s domain. The Domain Endpoint (Agency) unpack()’s the encrypted Wire Message and based on the <code class="docutils literal notranslate"><span class="pre">to</span></code> field value (the DID), sends the message to a designated Agent for that DID. How the Domain Endpoint knows where to send the message is implementation specific - likely some sort of dynamic DID-to-Agent routing table. Typically the message will be sent directly to the Routing Agent, although it doesn’t have to be. However, the message MUST get to the Routing Agent (3 in our example) as the message being forwarded has been encrypted for it.</p>
</div>
<div class="section" id="required-the-routing-agent-processes-the-outer-forward">
<span id="required-the-routing-agent-processes-the-outer-forward"></span><h3>Required: The Routing Agent Processes the Outer Forward<a class="headerlink" href="#required-the-routing-agent-processes-the-outer-forward" title="Permalink to this headline">¶</a></h3>
<p>When the Routing Agent (eventually) receives the message, it determines it is the target of the outer forward Agent Message and so decrypts the message’s <code class="docutils literal notranslate"><span class="pre">msg</span></code> value to reveal the inner “Forward” message. Recall that this inner Forward includes the full “DID#keyname” necessary to route the message to the intended Receiver agent. The Routing Agent uses its (implementation specific) knowledge to map from the DID#keyname to the Receiver, possibly via intermediary Agents. Note that the Routing Agent could itself be the Receiver and thus, have to decrypt and process the embedded message without further routing.</p>
</div>
<div class="section" id="required-the-receiver-app-agent-decrypts-processes-the-agent-message">
<span id="required-the-receiver-app-agent-decrypts-processes-the-agent-message"></span><h3>Required: The Receiver App Agent Decrypts/Processes the Agent Message<a class="headerlink" href="#required-the-receiver-app-agent-decrypts-processes-the-agent-message" title="Permalink to this headline">¶</a></h3>
<p>When the intended Receiver Agent receives the message, it determines it is the target of the Forward and decrypts the payload and processes the message.</p>
</div>
<div class="section" id="exposed-data">
<span id="exposed-data"></span><h3>Exposed Data<a class="headerlink" href="#exposed-data" title="Permalink to this headline">¶</a></h3>
<p>The following summarizes the information needed by the Sender’s agents:</p>
<ul class="simple">
<li>The DID to use for the relationship, and its related DIDDoc</li>
<li>From the DIDDoc:<ul>
<li>The Domain Endpoint’s physical endpoint and public key</li>
<li>The Routing Agent’s public key</li>
<li>The Receiver of the Agent Message’s public key</li>
</ul>
</li>
</ul>
<p>Thus, every Messaging DIDDoc is assumed to have at least one endpoint and three keys:</p>
<ul class="simple">
<li>The endpoint for the Domain Endpoint</li>
<li>The public key for the Domain Endpoint</li>
<li>The public key for the Routing Agent</li>
<li>The public key for the Receiver Agent</li>
</ul>
<p>The DIDDoc will have an additional key for each additional Agent Message Receiver.</p>
<p>As defined in the DIDDoc Conventions HIPE, the endpoint and public key for the Domain Endpoint are found by resolving the Domain Endpoint’s DID that is a service endpoint in the Receiver’s DIDDoc.</p>
<div class="section" id="degenerate-cases">
<span id="degenerate-cases"></span><h4>Degenerate Cases<a class="headerlink" href="#degenerate-cases" title="Permalink to this headline">¶</a></h4>
<p>The sequence above requires there are at least three Agents within every domain, and there could be many more. However, what if there are only 2 or even 1 Agent in a domain?</p>
<p>The HIPE requirement in those degenerate cases is that the DIDDoc MUST contain the same data (one endpoint, three public keys), and so the implementation MUST handle this as an “Agents with multiple roles” use case. The DIDDoc SHOULD be implemented such that Agents have different keys for different purposes to mask the simplified Agent structure.</p>
</div>
</div>
<div class="section" id="data-not-exposed">
<span id="data-not-exposed"></span><h3>Data Not Exposed<a class="headerlink" href="#data-not-exposed" title="Permalink to this headline">¶</a></h3>
<p>Given the sequence specified above, the following data is <strong>NOT</strong> exposed to the Sender’s agents:</p>
<ul class="simple">
<li>Routing-only Agents within the Receiver’s domain</li>
<li>Agents the identity chooses not to include in a given DIDDoc</li>
<li>The physical endpoints of Agents within the Receiver’s domain (other than the Domain Endpoint)<ul>
<li>The physical endpoints and, as required, associated public keys, are shared as needed within the Receiver’s domain.</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div class="section" id="message-types">
<span id="message-types"></span><h1>Message Types<a class="headerlink" href="#message-types" title="Permalink to this headline">¶</a></h1>
<p>The following Message Types are defined in this HIPE.</p>
<div class="section" id="core-routing-1-0-forward">
<span id="core-routing-1-0-forward"></span><h2>Core:Routing:1.0:Forward<a class="headerlink" href="#core-routing-1-0-forward" title="Permalink to this headline">¶</a></h2>
<p>The core message type “forward”, version 1.0 of the “routing” family is defined in this HIPE. An example of the message is the following:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;@type&quot;</span> <span class="p">:</span> <span class="s2">&quot;did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/routing/1.0/forward&quot;</span><span class="p">,</span>
  <span class="nt">&quot;to&quot;</span>   <span class="p">:</span> <span class="s2">&quot;did:sov:1234abcd#4&quot;</span><span class="p">,</span>
  <span class="nt">&quot;msg&quot;</span>  <span class="p">:</span> <span class="s2">&quot;&lt;pack(AgentMessage,valueOf(did:sov:1234abcd#4), privKey(A.did@A:B#1))&gt;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">to</span></code> field is required and takes one of two forms:</p>
<ul class="simple">
<li>A DID without a key reference (e.g. <code class="docutils literal notranslate"><span class="pre">did:sov:1234abcd</span></code>)</li>
<li>A DID with a key reference (e.g. <code class="docutils literal notranslate"><span class="pre">did:sov:1234abcd#4</span></code>)</li>
</ul>
<p>The first form is used when sending forward messages across one or more agents that do not need to know the details of a domain. The Receiver of the message is the designated <code class="docutils literal notranslate"><span class="pre">Routing</span> <span class="pre">Agent</span></code> in the Receiver Domain, as it controls the key used to decrypt messages sent to the domain, but not to a specific Agent.</p>
<p>The second form is used when the precise key (and hence, the Agent controlling that key) is used to encrypt the Agent Message placed in the <code class="docutils literal notranslate"><span class="pre">msg</span></code> field.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">msg</span></code> field calls the Indy-SDK <code class="docutils literal notranslate"><span class="pre">pack()</span></code> function to encrypt the Agent Message to be forwarded. The Sender calls the <code class="docutils literal notranslate"><span class="pre">pack()</span></code> with the suitable arguments to AnonCrypt or AuthCrypt the message. The <code class="docutils literal notranslate"><span class="pre">pack()</span></code> and <code class="docutils literal notranslate"><span class="pre">unpack()</span></code> functions are described in more detail in the <code class="docutils literal notranslate"><span class="pre">Wire</span> <span class="pre">Messages</span></code> HIPE (<em>reference to be added</em>).</p>
</div>
</div>
<div class="section" id="reference">
<span id="reference"></span><h1>Reference<a class="headerlink" href="#reference" title="Permalink to this headline">¶</a></h1>
<p>See the other HIPEs referenced in this document:</p>
<ul class="simple">
<li>Wire Messages</li>
<li>Agent Messages</li>
<li>DIDDoc Conventions</li>
</ul>
<p>(<em>References to be added</em>)</p>
</div>
<div class="section" id="drawbacks">
<span id="drawbacks"></span><h1>Drawbacks<a class="headerlink" href="#drawbacks" title="Permalink to this headline">¶</a></h1>
<p>The extra privacy gained from double-encrypting the message (as outlined in the second diagram above) to hide from the shared Domain Endpoint what seems to be a fairly limited amount of data (the <code class="docutils literal notranslate"><span class="pre">#keyname</span></code> fragment of the <code class="docutils literal notranslate"><span class="pre">to</span></code> field) seems onerous. A challenge will be to be able to explain to others implementing the protocol why this requirement is included. Only those that have a sufficient background in privacy are qualified to determine if the extra layer of encryption is necessary. For now we’ll leave it in.</p>
</div>
<div class="section" id="rationale-and-alternatives">
<span id="rationale-and-alternatives"></span><h1>Rationale and alternatives<a class="headerlink" href="#rationale-and-alternatives" title="Permalink to this headline">¶</a></h1>
<p>A number of discussions were held about this HIPE. In those discussions, the rationale for the HIPE evolved into the text, and the alternatives were eliminated. See prior versions of the HIPE for details.</p>
<p>A suggestion was made that the following optional parameters could be defined in the “routing/1.0/forward” message type:</p>
<ul class="simple">
<li><strong>forward-after</strong>: specify that the message should not be forwarded until the system clock shows a particular time, or until a particular interval has elapsed. This could be useful to defeat timing correlations. Particular agents might not support it.</li>
<li><strong>mix-config</strong>: artificially introduce extra hops to obscure path (use a mix network like TOR)</li>
</ul>
<p>The optional parameters have been left off for now, but could be added in this HIPE or to a later version of the message type.</p>
</div>
<div class="section" id="prior-art">
<span id="prior-art"></span><h1>Prior art<a class="headerlink" href="#prior-art" title="Permalink to this headline">¶</a></h1>
<p>N/A</p>
</div>
<div class="section" id="unresolved-questions">
<span id="unresolved-questions"></span><h1>Unresolved questions<a class="headerlink" href="#unresolved-questions" title="Permalink to this headline">¶</a></h1>
<p>N/A</p>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Hyperledger Indy

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>